import { createFocusTrap, useClickOutside, useEscapeKeydown, useFloating, usePortal, } from '../index.js';
import { executeCallbacks, noop, isHTMLElement, } from '../../helpers/index.js';
const defaultConfig = {
    floating: {},
    focusTrap: {},
    clickOutside: {},
    escapeKeydown: {},
    portal: 'body',
};
export const usePopper = (popperElement, args) => {
    popperElement.dataset.escapee = '';
    const { anchorElement, open, options } = args;
    if (!anchorElement || !open || !options) {
        return { destroy: noop };
    }
    const opts = { ...defaultConfig, ...options };
    const callbacks = [];
    if (opts.portal !== null) {
        const portal = usePortal(popperElement, opts.portal);
        if (portal?.destroy) {
            callbacks.push(portal.destroy);
        }
    }
    callbacks.push(useFloating(anchorElement, popperElement, opts.floating).destroy);
    if (opts.focusTrap !== null) {
        const { useFocusTrap } = createFocusTrap({
            immediate: true,
            escapeDeactivates: false,
            allowOutsideClick: true,
            returnFocusOnDeactivate: false,
            fallbackFocus: popperElement,
            ...opts.focusTrap,
        });
        const usedFocusTrap = useFocusTrap(popperElement);
        if (usedFocusTrap?.destroy) {
            callbacks.push(usedFocusTrap.destroy);
        }
    }
    if (opts.clickOutside !== null) {
        callbacks.push(useClickOutside(popperElement, {
            enabled: open,
            handler: (e) => {
                if (e.defaultPrevented)
                    return;
                if (isHTMLElement(anchorElement) && !anchorElement.contains(e.target)) {
                    open.set(false);
                    anchorElement.focus();
                }
            },
            ...opts.clickOutside,
        }).destroy);
    }
    if (opts.escapeKeydown !== null) {
        callbacks.push(useEscapeKeydown(popperElement, {
            enabled: open,
            handler: () => {
                open.set(false);
            },
            ...opts.escapeKeydown,
        }).destroy);
    }
    // @ts-expect-error - This works and is correct, but TS doesn't like it
    const unsubscribe = executeCallbacks(...callbacks);
    return {
        destroy() {
            unsubscribe();
        },
    };
};
